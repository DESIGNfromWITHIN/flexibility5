<?php return array (
  'preserve_keys' => false,
  'update_object' => true,
  'unique_key' => 'name',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"getresources-1.6.1-pl\\/modSnippet\\/8602b11ae850890acd8e9af0bb1862f7\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"getresources"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'a90c6a7ead495f4abc9142ae95e9ca33',
  'package' => 'modx',
  'class' => 'modSnippet',
  'signature' => '8602b11ae850890acd8e9af0bb1862f7',
  'native_key' => NULL,
  'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"getResources","description":"<strong>1.6.1-pl<\\/strong> A general purpose Resource listing and summarization snippet for MODX Revolution","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * getResources\\n *\\n * A general purpose Resource listing and summarization snippet for MODX 2.x.\\n *\\n * @author Jason Coward\\n * @copyright Copyright 2010-2013, Jason Coward\\n *\\n * TEMPLATES\\n *\\n * tpl - Name of a chunk serving as a resource template\\n * [NOTE: if not provided, properties are dumped to output for each resource]\\n *\\n * tplOdd - (Opt) Name of a chunk serving as resource template for resources with an odd idx value\\n * (see idx property)\\n * tplFirst - (Opt) Name of a chunk serving as resource template for the first resource (see first\\n * property)\\n * tplLast - (Opt) Name of a chunk serving as resource template for the last resource (see last\\n * property)\\n * tpl_{n} - (Opt) Name of a chunk serving as resource template for the nth resource\\n *\\n * tplCondition - (Opt) Defines a field of the resource to evaluate against keys defined in the\\n * conditionalTpls property. Must be a resource field; does not work with Template Variables.\\n * conditionalTpls - (Opt) A JSON object defining a map of field values and the associated tpl to\\n * use when the field defined by tplCondition matches the value. [NOTE: tplOdd, tplFirst, tplLast,\\n * and tpl_{n} will take precedence over any defined conditionalTpls]\\n *\\n * tplWrapper - (Opt) Name of a chunk serving as a wrapper template for the output\\n * [NOTE: Does not work with toSeparatePlaceholders]\\n *\\n * SELECTION\\n *\\n * parents - Comma-delimited list of ids serving as parents\\n *\\n * context - (Opt) Comma-delimited list of context keys to limit results by; if empty, contexts for all specified\\n * parents will be used (all contexts if 0 is specified) [default=]\\n *\\n * depth - (Opt) Integer value indicating depth to search for resources from each parent [default=10]\\n *\\n * tvFilters - (Opt) Delimited-list of TemplateVar values to filter resources by. Supports two\\n * delimiters and two value search formats. The first delimiter || represents a logical OR and the\\n * primary grouping mechanism.  Within each group you can provide a comma-delimited list of values.\\n * These values can be either tied to a specific TemplateVar by name, e.g. myTV==value, or just the\\n * value, indicating you are searching for the value in any TemplateVar tied to the Resource. An\\n * example would be &tvFilters=`filter2==one,filter1==bar%||filter1==foo`\\n * [NOTE: filtering by values uses a LIKE query and % is considered a wildcard.]\\n * [NOTE: this only looks at the raw value set for specific Resource, i. e. there must be a value\\n * specifically set for the Resource and it is not evaluated.]\\n *\\n * tvFiltersAndDelimiter - (Opt) Custom delimiter for logical AND, default \',\', in case you want to\\n * match a literal comma in the tvFilters. E.g. &tvFiltersAndDelimiter=`&&`\\n * &tvFilters=`filter1==foo,bar&&filter2==baz` [default=,]\\n *\\n * tvFiltersOrDelimiter - (Opt) Custom delimiter for logical OR, default \'||\', in case you want to\\n * match a literal \'||\' in the tvFilters. E.g. &tvFiltersOrDelimiter=`|OR|`\\n * &tvFilters=`filter1==foo||bar|OR|filter2==baz` [default=||]\\n *\\n * where - (Opt) A JSON expression of criteria to build any additional where clauses from. An example would be\\n * &where=`{{\\"alias:LIKE\\":\\"foo%\\", \\"OR:alias:LIKE\\":\\"%bar\\"},{\\"OR:pagetitle:=\\":\\"foobar\\", \\"AND:description:=\\":\\"raboof\\"}}`\\n *\\n * sortby - (Opt) Field to sort by or a JSON array, e.g. {\\"publishedon\\":\\"ASC\\",\\"createdon\\":\\"DESC\\"} [default=publishedon]\\n * sortbyTV - (opt) A Template Variable name to sort by (if supplied, this precedes the sortby value) [default=]\\n * sortbyTVType - (Opt) A data type to CAST a TV Value to in order to sort on it properly [default=string]\\n * sortbyAlias - (Opt) Query alias for sortby field [default=]\\n * sortbyEscaped - (Opt) Escapes the field name(s) specified in sortby [default=0]\\n * sortdir - (Opt) Order which to sort by [default=DESC]\\n * sortdirTV - (Opt) Order which to sort by a TV [default=DESC]\\n * limit - (Opt) Limits the number of resources returned [default=5]\\n * offset - (Opt) An offset of resources returned by the criteria to skip [default=0]\\n * dbCacheFlag - (Opt) Controls caching of db queries; 0|false = do not cache result set; 1 = cache result set\\n * according to cache settings, any other integer value = number of seconds to cache result set [default=0]\\n *\\n * OPTIONS\\n *\\n * includeContent - (Opt) Indicates if the content of each resource should be returned in the\\n * results [default=0]\\n * includeTVs - (Opt) Indicates if TemplateVar values should be included in the properties available\\n * to each resource template [default=0]\\n * includeTVList - (Opt) Limits the TemplateVars that are included if includeTVs is true to those specified\\n * by name in a comma-delimited list [default=]\\n * prepareTVs - (Opt) Prepares media-source dependent TemplateVar values [default=1]\\n * prepareTVList - (Opt) Limits the TVs that are prepared to those specified by name in a comma-delimited\\n * list [default=]\\n * processTVs - (Opt) Indicates if TemplateVar values should be rendered as they would on the\\n * resource being summarized [default=0]\\n * processTVList - (opt) Limits the TemplateVars that are processed if included to those specified\\n * by name in a comma-delimited list [default=]\\n * tvPrefix - (Opt) The prefix for TemplateVar properties [default=tv.]\\n * idx - (Opt) You can define the starting idx of the resources, which is an property that is\\n * incremented as each resource is rendered [default=1]\\n * first - (Opt) Define the idx which represents the first resource (see tplFirst) [default=1]\\n * last - (Opt) Define the idx which represents the last resource (see tplLast) [default=# of\\n * resources being summarized + first - 1]\\n * outputSeparator - (Opt) An optional string to separate each tpl instance [default=\\"\\\\n\\"]\\n * wrapIfEmpty - (Opt) Indicates if the tplWrapper should be applied if the output is empty [default=0]\\n *\\n *\\/\\n$output = array();\\n$outputSeparator = isset($outputSeparator) ? $outputSeparator : \\"\\\\n\\";\\n\\n\\/* set default properties *\\/\\n$tpl = !empty($tpl) ? $tpl : \'\';\\n$includeContent = !empty($includeContent) ? true : false;\\n$includeTVs = !empty($includeTVs) ? true : false;\\n$includeTVList = !empty($includeTVList) ? explode(\',\', $includeTVList) : array();\\n$processTVs = !empty($processTVs) ? true : false;\\n$processTVList = !empty($processTVList) ? explode(\',\', $processTVList) : array();\\n$prepareTVs = !empty($prepareTVs) ? true : false;\\n$prepareTVList = !empty($prepareTVList) ? explode(\',\', $prepareTVList) : array();\\n$tvPrefix = isset($tvPrefix) ? $tvPrefix : \'tv.\';\\n$parents = (!empty($parents) || $parents === \'0\') ? explode(\',\', $parents) : array($modx->resource->get(\'id\'));\\narray_walk($parents, \'trim\');\\n$parents = array_unique($parents);\\n$depth = isset($depth) ? (integer) $depth : 10;\\n\\n$tvFiltersOrDelimiter = isset($tvFiltersOrDelimiter) ? $tvFiltersOrDelimiter : \'||\';\\n$tvFiltersAndDelimiter = isset($tvFiltersAndDelimiter) ? $tvFiltersAndDelimiter : \',\';\\n$tvFilters = !empty($tvFilters) ? explode($tvFiltersOrDelimiter, $tvFilters) : array();\\n\\n$where = !empty($where) ? $modx->fromJSON($where) : array();\\n$showUnpublished = !empty($showUnpublished) ? true : false;\\n$showDeleted = !empty($showDeleted) ? true : false;\\n\\n$sortby = isset($sortby) ? $sortby : \'publishedon\';\\n$sortbyTV = isset($sortbyTV) ? $sortbyTV : \'\';\\n$sortbyAlias = isset($sortbyAlias) ? $sortbyAlias : \'modResource\';\\n$sortbyEscaped = !empty($sortbyEscaped) ? true : false;\\n$sortdir = isset($sortdir) ? $sortdir : \'DESC\';\\n$sortdirTV = isset($sortdirTV) ? $sortdirTV : \'DESC\';\\n$limit = isset($limit) ? (integer) $limit : 5;\\n$offset = isset($offset) ? (integer) $offset : 0;\\n$totalVar = !empty($totalVar) ? $totalVar : \'total\';\\n\\n$dbCacheFlag = !isset($dbCacheFlag) ? false : $dbCacheFlag;\\nif (is_string($dbCacheFlag) || is_numeric($dbCacheFlag)) {\\n    if ($dbCacheFlag == \'0\') {\\n        $dbCacheFlag = false;\\n    } elseif ($dbCacheFlag == \'1\') {\\n        $dbCacheFlag = true;\\n    } else {\\n        $dbCacheFlag = (integer) $dbCacheFlag;\\n    }\\n}\\n\\n\\/* multiple context support *\\/\\n$contextArray = array();\\n$contextSpecified = false;\\nif (!empty($context)) {\\n    $contextArray = explode(\',\',$context);\\n    array_walk($contextArray, \'trim\');\\n    $contexts = array();\\n    foreach ($contextArray as $ctx) {\\n        $contexts[] = $modx->quote($ctx);\\n    }\\n    $context = implode(\',\',$contexts);\\n    $contextSpecified = true;\\n    unset($contexts,$ctx);\\n} else {\\n    $context = $modx->quote($modx->context->get(\'key\'));\\n}\\n\\n$pcMap = array();\\n$pcQuery = $modx->newQuery(\'modResource\', array(\'id:IN\' => $parents), $dbCacheFlag);\\n$pcQuery->select(array(\'id\', \'context_key\'));\\nif ($pcQuery->prepare() && $pcQuery->stmt->execute()) {\\n    foreach ($pcQuery->stmt->fetchAll(PDO::FETCH_ASSOC) as $pcRow) {\\n        $pcMap[(integer) $pcRow[\'id\']] = $pcRow[\'context_key\'];\\n    }\\n}\\n\\n$children = array();\\n$parentArray = array();\\nforeach ($parents as $parent) {\\n    $parent = (integer) $parent;\\n    if ($parent === 0) {\\n        $pchildren = array();\\n        if ($contextSpecified) {\\n            foreach ($contextArray as $pCtx) {\\n                if (!in_array($pCtx, $contextArray)) {\\n                    continue;\\n                }\\n                $options = $pCtx !== $modx->context->get(\'key\') ? array(\'context\' => $pCtx) : array();\\n                $pcchildren = $modx->getChildIds($parent, $depth, $options);\\n                if (!empty($pcchildren)) $pchildren = array_merge($pchildren, $pcchildren);\\n            }\\n        } else {\\n            $cQuery = $modx->newQuery(\'modContext\', array(\'key:!=\' => \'mgr\'));\\n            $cQuery->select(array(\'key\'));\\n            if ($cQuery->prepare() && $cQuery->stmt->execute()) {\\n                foreach ($cQuery->stmt->fetchAll(PDO::FETCH_COLUMN) as $pCtx) {\\n                    $options = $pCtx !== $modx->context->get(\'key\') ? array(\'context\' => $pCtx) : array();\\n                    $pcchildren = $modx->getChildIds($parent, $depth, $options);\\n                    if (!empty($pcchildren)) $pchildren = array_merge($pchildren, $pcchildren);\\n                }\\n            }\\n        }\\n        $parentArray[] = $parent;\\n    } else {\\n        $pContext = array_key_exists($parent, $pcMap) ? $pcMap[$parent] : false;\\n        if ($debug) $modx->log(modX::LOG_LEVEL_ERROR, \\"context for {$parent} is {$pContext}\\");\\n        if ($pContext && $contextSpecified && !in_array($pContext, $contextArray, true)) {\\n            $parent = next($parents);\\n            continue;\\n        }\\n        $parentArray[] = $parent;\\n        $options = !empty($pContext) && $pContext !== $modx->context->get(\'key\') ? array(\'context\' => $pContext) : array();\\n        $pchildren = $modx->getChildIds($parent, $depth, $options);\\n    }\\n    if (!empty($pchildren)) $children = array_merge($children, $pchildren);\\n    $parent = next($parents);\\n}\\n$parents = array_merge($parentArray, $children);\\n\\n\\/* build query *\\/\\n$criteria = array(\\"modResource.parent IN (\\" . implode(\',\', $parents) . \\")\\");\\nif ($contextSpecified) {\\n    $contextResourceTbl = $modx->getTableName(\'modContextResource\');\\n    $criteria[] = \\"(modResource.context_key IN ({$context}) OR EXISTS(SELECT 1 FROM {$contextResourceTbl} ctx WHERE ctx.resource = modResource.id AND ctx.context_key IN ({$context})))\\";\\n}\\nif (empty($showDeleted)) {\\n    $criteria[\'deleted\'] = \'0\';\\n}\\nif (empty($showUnpublished)) {\\n    $criteria[\'published\'] = \'1\';\\n}\\nif (empty($showHidden)) {\\n    $criteria[\'hidemenu\'] = \'0\';\\n}\\nif (!empty($hideContainers)) {\\n    $criteria[\'isfolder\'] = \'0\';\\n}\\n$criteria = $modx->newQuery(\'modResource\', $criteria);\\nif (!empty($tvFilters)) {\\n    $tmplVarTbl = $modx->getTableName(\'modTemplateVar\');\\n    $tmplVarResourceTbl = $modx->getTableName(\'modTemplateVarResource\');\\n    $conditions = array();\\n    $operators = array(\\n        \'<=>\' => \'<=>\',\\n        \'===\' => \'=\',\\n        \'!==\' => \'!=\',\\n        \'<>\' => \'<>\',\\n        \'==\' => \'LIKE\',\\n        \'!=\' => \'NOT LIKE\',\\n        \'<<\' => \'<\',\\n        \'<=\' => \'<=\',\\n        \'=<\' => \'=<\',\\n        \'>>\' => \'>\',\\n        \'>=\' => \'>=\',\\n        \'=>\' => \'=>\'\\n    );\\n    foreach ($tvFilters as $fGroup => $tvFilter) {\\n        $filterGroup = array();\\n        $filters = explode($tvFiltersAndDelimiter, $tvFilter);\\n        $multiple = count($filters) > 0;\\n        foreach ($filters as $filter) {\\n            $operator = \'==\';\\n            $sqlOperator = \'LIKE\';\\n            foreach ($operators as $op => $opSymbol) {\\n                if (strpos($filter, $op, 1) !== false) {\\n                    $operator = $op;\\n                    $sqlOperator = $opSymbol;\\n                    break;\\n                }\\n            }\\n            $tvValueField = \'tvr.value\';\\n            $tvDefaultField = \'tv.default_text\';\\n            $f = explode($operator, $filter);\\n            if (count($f) >= 2) {\\n                if (count($f) > 2) {\\n                    $k = array_shift($f);\\n                    $b = join($operator, $f);\\n                    $f = array($k, $b);\\n                }\\n                $tvName = $modx->quote($f[0]);\\n                if (is_numeric($f[1]) && !in_array($sqlOperator, array(\'LIKE\', \'NOT LIKE\'))) {\\n                    $tvValue = $f[1];\\n                    if ($f[1] == (integer)$f[1]) {\\n                        $tvValueField = \\"CAST({$tvValueField} AS SIGNED INTEGER)\\";\\n                        $tvDefaultField = \\"CAST({$tvDefaultField} AS SIGNED INTEGER)\\";\\n                    } else {\\n                        $tvValueField = \\"CAST({$tvValueField} AS DECIMAL)\\";\\n                        $tvDefaultField = \\"CAST({$tvDefaultField} AS DECIMAL)\\";\\n                    }\\n                } else {\\n                    $tvValue = $modx->quote($f[1]);\\n                }\\n                if ($multiple) {\\n                    $filterGroup[] =\\n                        \\"(EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.name = {$tvName} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id) \\" .\\n                        \\"OR EXISTS (SELECT 1 FROM {$tmplVarTbl} tv WHERE tv.name = {$tvName} AND {$tvDefaultField} {$sqlOperator} {$tvValue} AND tv.id NOT IN (SELECT tmplvarid FROM {$tmplVarResourceTbl} WHERE contentid = modResource.id)) \\" .\\n                        \\")\\";\\n                } else {\\n                    $filterGroup =\\n                        \\"(EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.name = {$tvName} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id) \\" .\\n                        \\"OR EXISTS (SELECT 1 FROM {$tmplVarTbl} tv WHERE tv.name = {$tvName} AND {$tvDefaultField} {$sqlOperator} {$tvValue} AND tv.id NOT IN (SELECT tmplvarid FROM {$tmplVarResourceTbl} WHERE contentid = modResource.id)) \\" .\\n                        \\")\\";\\n                }\\n            } elseif (count($f) == 1) {\\n                $tvValue = $modx->quote($f[0]);\\n                if ($multiple) {\\n                    $filterGroup[] = \\"EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id)\\";\\n                } else {\\n                    $filterGroup = \\"EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id)\\";\\n                }\\n            }\\n        }\\n        $conditions[] = $filterGroup;\\n    }\\n    if (!empty($conditions)) {\\n        $firstGroup = true;\\n        foreach ($conditions as $cGroup => $c) {\\n            if (is_array($c)) {\\n                $first = true;\\n                foreach ($c as $cond) {\\n                    if ($first && !$firstGroup) {\\n                        $criteria->condition($criteria->query[\'where\'][0][1], $cond, xPDOQuery::SQL_OR, null, $cGroup);\\n                    } else {\\n                        $criteria->condition($criteria->query[\'where\'][0][1], $cond, xPDOQuery::SQL_AND, null, $cGroup);\\n                    }\\n                    $first = false;\\n                }\\n            } else {\\n                $criteria->condition($criteria->query[\'where\'][0][1], $c, $firstGroup ? xPDOQuery::SQL_AND : xPDOQuery::SQL_OR, null, $cGroup);\\n            }\\n            $firstGroup = false;\\n        }\\n    }\\n}\\n\\/* include\\/exclude resources, via &resources=`123,-456` prop *\\/\\nif (!empty($resources)) {\\n    $resourceConditions = array();\\n    $resources = explode(\',\',$resources);\\n    $include = array();\\n    $exclude = array();\\n    foreach ($resources as $resource) {\\n        $resource = (int)$resource;\\n        if ($resource == 0) continue;\\n        if ($resource < 0) {\\n            $exclude[] = abs($resource);\\n        } else {\\n            $include[] = $resource;\\n        }\\n    }\\n    if (!empty($include)) {\\n        $criteria->where(array(\'OR:modResource.id:IN\' => $include), xPDOQuery::SQL_OR);\\n    }\\n    if (!empty($exclude)) {\\n        $criteria->where(array(\'modResource.id:NOT IN\' => $exclude), xPDOQuery::SQL_AND, null, 1);\\n    }\\n}\\nif (!empty($where)) {\\n    $criteria->where($where);\\n}\\n\\n$total = $modx->getCount(\'modResource\', $criteria);\\n$modx->setPlaceholder($totalVar, $total);\\n\\n$fields = array_keys($modx->getFields(\'modResource\'));\\nif (empty($includeContent)) {\\n    $fields = array_diff($fields, array(\'content\'));\\n}\\n$columns = $includeContent ? $modx->getSelectColumns(\'modResource\', \'modResource\') : $modx->getSelectColumns(\'modResource\', \'modResource\', \'\', array(\'content\'), true);\\n$criteria->select($columns);\\nif (!empty($sortbyTV)) {\\n    $criteria->leftJoin(\'modTemplateVar\', \'tvDefault\', array(\\n        \\"tvDefault.name\\" => $sortbyTV\\n    ));\\n    $criteria->leftJoin(\'modTemplateVarResource\', \'tvSort\', array(\\n        \\"tvSort.contentid = modResource.id\\",\\n        \\"tvSort.tmplvarid = tvDefault.id\\"\\n    ));\\n    if (empty($sortbyTVType)) $sortbyTVType = \'string\';\\n    if ($modx->getOption(\'dbtype\') === \'mysql\') {\\n        switch ($sortbyTVType) {\\n            case \'integer\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS SIGNED INTEGER) AS sortTV\\");\\n                break;\\n            case \'decimal\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS DECIMAL) AS sortTV\\");\\n                break;\\n            case \'datetime\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS DATETIME) AS sortTV\\");\\n                break;\\n            case \'string\':\\n            default:\\n                $criteria->select(\\"IFNULL(tvSort.value, tvDefault.default_text) AS sortTV\\");\\n                break;\\n        }\\n    } elseif ($modx->getOption(\'dbtype\') === \'sqlsrv\') {\\n        switch ($sortbyTVType) {\\n            case \'integer\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS BIGINT) AS sortTV\\");\\n                break;\\n            case \'decimal\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS DECIMAL) AS sortTV\\");\\n                break;\\n            case \'datetime\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS DATETIME) AS sortTV\\");\\n                break;\\n            case \'string\':\\n            default:\\n                $criteria->select(\\"ISNULL(tvSort.value, tvDefault.default_text) AS sortTV\\");\\n                break;\\n        }\\n    }\\n    $criteria->sortby(\\"sortTV\\", $sortdirTV);\\n}\\nif (!empty($sortby)) {\\n    if (strpos($sortby, \'{\') === 0) {\\n        $sorts = $modx->fromJSON($sortby);\\n    } else {\\n        $sorts = array($sortby => $sortdir);\\n    }\\n    if (is_array($sorts)) {\\n        while (list($sort, $dir) = each($sorts)) {\\n            if ($sortbyEscaped) $sort = $modx->escape($sort);\\n            if (!empty($sortbyAlias)) $sort = $modx->escape($sortbyAlias) . \\".{$sort}\\";\\n            $criteria->sortby($sort, $dir);\\n        }\\n    }\\n}\\nif (!empty($limit)) $criteria->limit($limit, $offset);\\n\\nif (!empty($debug)) {\\n    $criteria->prepare();\\n    $modx->log(modX::LOG_LEVEL_ERROR, $criteria->toSQL());\\n}\\n$collection = $modx->getCollection(\'modResource\', $criteria, $dbCacheFlag);\\n\\n$idx = !empty($idx) || $idx === \'0\' ? (integer) $idx : 1;\\n$first = empty($first) && $first !== \'0\' ? 1 : (integer) $first;\\n$last = empty($last) ? (count($collection) + $idx - 1) : (integer) $last;\\n\\n\\/* include parseTpl *\\/\\ninclude_once $modx->getOption(\'getresources.core_path\',null,$modx->getOption(\'core_path\').\'components\\/getresources\\/\').\'include.parsetpl.php\';\\n\\n$templateVars = array();\\nif (!empty($includeTVs) && !empty($includeTVList)) {\\n    $templateVars = $modx->getCollection(\'modTemplateVar\', array(\'name:IN\' => $includeTVList));\\n}\\n\\/** @var modResource $resource *\\/\\nforeach ($collection as $resourceId => $resource) {\\n    $tvs = array();\\n    if (!empty($includeTVs)) {\\n        if (empty($includeTVList)) {\\n            $templateVars = $resource->getMany(\'TemplateVars\');\\n        }\\n        \\/** @var modTemplateVar $templateVar *\\/\\n        foreach ($templateVars as $tvId => $templateVar) {\\n            if (!empty($includeTVList) && !in_array($templateVar->get(\'name\'), $includeTVList)) continue;\\n            if ($processTVs && (empty($processTVList) || in_array($templateVar->get(\'name\'), $processTVList))) {\\n                $tvs[$tvPrefix . $templateVar->get(\'name\')] = $templateVar->renderOutput($resource->get(\'id\'));\\n            } else {\\n                $value = $templateVar->getValue($resource->get(\'id\'));\\n                if ($prepareTVs && method_exists($templateVar, \'prepareOutput\') && (empty($prepareTVList) || in_array($templateVar->get(\'name\'), $prepareTVList))) {\\n                    $value = $templateVar->prepareOutput($value);\\n                }\\n                $tvs[$tvPrefix . $templateVar->get(\'name\')] = $value;\\n            }\\n        }\\n    }\\n    $odd = ($idx & 1);\\n    $properties = array_merge(\\n        $scriptProperties\\n        ,array(\\n            \'idx\' => $idx\\n            ,\'first\' => $first\\n            ,\'last\' => $last\\n            ,\'odd\' => $odd\\n        )\\n        ,$includeContent ? $resource->toArray() : $resource->get($fields)\\n        ,$tvs\\n    );\\n    $resourceTpl = false;\\n    if ($idx == $first && !empty($tplFirst)) {\\n        $resourceTpl = parseTpl($tplFirst, $properties);\\n    }\\n    if ($idx == $last && empty($resourceTpl) && !empty($tplLast)) {\\n        $resourceTpl = parseTpl($tplLast, $properties);\\n    }\\n    $tplidx = \'tpl_\' . $idx;\\n    if (empty($resourceTpl) && !empty($$tplidx)) {\\n        $resourceTpl = parseTpl($$tplidx, $properties);\\n    }\\n    if ($idx > 1 && empty($resourceTpl)) {\\n        $divisors = getDivisors($idx);\\n        if (!empty($divisors)) {\\n            foreach ($divisors as $divisor) {\\n                $tplnth = \'tpl_n\' . $divisor;\\n                if (!empty($$tplnth)) {\\n                    $resourceTpl = parseTpl($$tplnth, $properties);\\n                    if (!empty($resourceTpl)) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    if ($odd && empty($resourceTpl) && !empty($tplOdd)) {\\n        $resourceTpl = parseTpl($tplOdd, $properties);\\n    }\\n    if (!empty($tplCondition) && !empty($conditionalTpls) && empty($resourceTpl)) {\\n        $conTpls = $modx->fromJSON($conditionalTpls);\\n        $subject = $properties[$tplCondition];\\n        $tplOperator = !empty($tplOperator) ? $tplOperator : \'=\';\\n        $tplOperator = strtolower($tplOperator);\\n        $tplCon = \'\';\\n        foreach ($conTpls as $operand => $conditionalTpl) {\\n            switch ($tplOperator) {\\n                case \'!=\':\\n                case \'neq\':\\n                case \'not\':\\n                case \'isnot\':\\n                case \'isnt\':\\n                case \'unequal\':\\n                case \'notequal\':\\n                    $tplCon = (($subject != $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'<\':\\n                case \'lt\':\\n                case \'less\':\\n                case \'lessthan\':\\n                    $tplCon = (($subject < $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'>\':\\n                case \'gt\':\\n                case \'greater\':\\n                case \'greaterthan\':\\n                    $tplCon = (($subject > $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'<=\':\\n                case \'lte\':\\n                case \'lessthanequals\':\\n                case \'lessthanorequalto\':\\n                    $tplCon = (($subject <= $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'>=\':\\n                case \'gte\':\\n                case \'greaterthanequals\':\\n                case \'greaterthanequalto\':\\n                    $tplCon = (($subject >= $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'isempty\':\\n                case \'empty\':\\n                    $tplCon = empty($subject) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'!empty\':\\n                case \'notempty\':\\n                case \'isnotempty\':\\n                    $tplCon = !empty($subject) && $subject != \'\' ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'isnull\':\\n                case \'null\':\\n                    $tplCon = $subject == null || strtolower($subject) == \'null\' ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'inarray\':\\n                case \'in_array\':\\n                case \'ia\':\\n                    $operand = explode(\',\', $operand);\\n                    $tplCon = in_array($subject, $operand) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'between\':\\n                case \'range\':\\n                case \'>=<\':\\n                case \'><\':\\n                    $operand = explode(\',\', $operand);\\n                    $tplCon = ($subject >= min($operand) && $subject <= max($operand)) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'==\':\\n                case \'=\':\\n                case \'eq\':\\n                case \'is\':\\n                case \'equal\':\\n                case \'equals\':\\n                case \'equalto\':\\n                default:\\n                    $tplCon = (($subject == $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n            }\\n        }\\n        if (!empty($tplCon)) {\\n            $resourceTpl = parseTpl($tplCon, $properties);\\n        }\\n    }\\n    if (!empty($tpl) && empty($resourceTpl)) {\\n        $resourceTpl = parseTpl($tpl, $properties);\\n    }\\n    if ($resourceTpl === false && !empty($debug)) {\\n        $chunk = $modx->newObject(\'modChunk\');\\n        $chunk->setCacheable(false);\\n        $output[]= $chunk->process(array(), \'<pre>\' . print_r($properties, true) .\'<\\/pre>\');\\n    } else {\\n        $output[]= $resourceTpl;\\n    }\\n    $idx++;\\n}\\n\\n\\/* output *\\/\\n$toSeparatePlaceholders = $modx->getOption(\'toSeparatePlaceholders\', $scriptProperties, false);\\nif (!empty($toSeparatePlaceholders)) {\\n    $modx->setPlaceholders($output, $toSeparatePlaceholders);\\n    return \'\';\\n}\\n\\n$output = implode($outputSeparator, $output);\\n\\n$tplWrapper = $modx->getOption(\'tplWrapper\', $scriptProperties, false);\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, false);\\nif (!empty($tplWrapper) && ($wrapIfEmpty || !empty($output))) {\\n    $output = parseTpl($tplWrapper, array_merge($scriptProperties, array(\'output\' => $output)));\\n}\\n\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, false);\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $output);\\n    return \'\';\\n}\\nreturn $output;","locked":0,"properties":"a:44:{s:3:\\"tpl\\";a:7:{s:4:\\"name\\";s:3:\\"tpl\\";s:4:\\"desc\\";s:121:\\"Name of a chunk serving as a resource template. NOTE: if not provided, properties are dumped to output for each resource.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"tplOdd\\";a:7:{s:4:\\"name\\";s:6:\\"tplOdd\\";s:4:\\"desc\\";s:100:\\"Name of a chunk serving as resource template for resources with an odd idx value (see idx property).\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:8:\\"tplFirst\\";a:7:{s:4:\\"name\\";s:8:\\"tplFirst\\";s:4:\\"desc\\";s:89:\\"Name of a chunk serving as resource template for the first resource (see first property).\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"tplLast\\";a:7:{s:4:\\"name\\";s:7:\\"tplLast\\";s:4:\\"desc\\";s:87:\\"Name of a chunk serving as resource template for the last resource (see last property).\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"tplWrapper\\";a:7:{s:4:\\"name\\";s:10:\\"tplWrapper\\";s:4:\\"desc\\";s:115:\\"Name of a chunk serving as wrapper template for the Snippet output. This does not work with toSeparatePlaceholders.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:11:\\"wrapIfEmpty\\";a:7:{s:4:\\"name\\";s:11:\\"wrapIfEmpty\\";s:4:\\"desc\\";s:95:\\"Indicates if empty output should be wrapped by the tplWrapper, if specified. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"sortby\\";a:7:{s:4:\\"name\\";s:6:\\"sortby\\";s:4:\\"desc\\";s:153:\\"A field name to sort by or JSON object of field names and sortdir for each field, e.g. {\\"publishedon\\":\\"ASC\\",\\"createdon\\":\\"DESC\\"}. Defaults to publishedon.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:11:\\"publishedon\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:8:\\"sortbyTV\\";a:7:{s:4:\\"name\\";s:8:\\"sortbyTV\\";s:4:\\"desc\\";s:65:\\"Name of a Template Variable to sort by. Defaults to empty string.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:12:\\"sortbyTVType\\";a:7:{s:4:\\"name\\";s:12:\\"sortbyTVType\\";s:4:\\"desc\\";s:72:\\"An optional type to indicate how to sort on the Template Variable value.\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:4:{i:0;a:2:{s:4:\\"text\\";s:6:\\"string\\";s:5:\\"value\\";s:6:\\"string\\";}i:1;a:2:{s:4:\\"text\\";s:7:\\"integer\\";s:5:\\"value\\";s:7:\\"integer\\";}i:2;a:2:{s:4:\\"text\\";s:7:\\"decimal\\";s:5:\\"value\\";s:7:\\"decimal\\";}i:3;a:2:{s:4:\\"text\\";s:8:\\"datetime\\";s:5:\\"value\\";s:8:\\"datetime\\";}}s:5:\\"value\\";s:6:\\"string\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:11:\\"sortbyAlias\\";a:7:{s:4:\\"name\\";s:11:\\"sortbyAlias\\";s:4:\\"desc\\";s:58:\\"Query alias for sortby field. Defaults to an empty string.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:13:\\"sortbyEscaped\\";a:7:{s:4:\\"name\\";s:13:\\"sortbyEscaped\\";s:4:\\"desc\\";s:82:\\"Determines if the field name specified in sortby should be escaped. Defaults to 0.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"sortdir\\";a:7:{s:4:\\"name\\";s:7:\\"sortdir\\";s:4:\\"desc\\";s:41:\\"Order which to sort by. Defaults to DESC.\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:4:\\"text\\";s:3:\\"ASC\\";s:5:\\"value\\";s:3:\\"ASC\\";}i:1;a:2:{s:4:\\"text\\";s:4:\\"DESC\\";s:5:\\"value\\";s:4:\\"DESC\\";}}s:5:\\"value\\";s:4:\\"DESC\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:9:\\"sortdirTV\\";a:7:{s:4:\\"name\\";s:9:\\"sortdirTV\\";s:4:\\"desc\\";s:61:\\"Order which to sort a Template Variable by. Defaults to DESC.\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:4:\\"text\\";s:3:\\"ASC\\";s:5:\\"value\\";s:3:\\"ASC\\";}i:1;a:2:{s:4:\\"text\\";s:4:\\"DESC\\";s:5:\\"value\\";s:4:\\"DESC\\";}}s:5:\\"value\\";s:4:\\"DESC\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"limit\\";a:7:{s:4:\\"name\\";s:5:\\"limit\\";s:4:\\"desc\\";s:55:\\"Limits the number of resources returned. Defaults to 5.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"5\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"offset\\";a:7:{s:4:\\"name\\";s:6:\\"offset\\";s:4:\\"desc\\";s:56:\\"An offset of resources returned by the criteria to skip.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:9:\\"tvFilters\\";a:7:{s:4:\\"name\\";s:9:\\"tvFilters\\";s:4:\\"desc\\";s:778:\\"Delimited-list of TemplateVar values to filter resources by. Supports two delimiters and two value search formats. THe first delimiter || represents a logical OR and the primary grouping mechanism.  Within each group you can provide a comma-delimited list of values. These values can be either tied to a specific TemplateVar by name, e.g. myTV==value, or just the value, indicating you are searching for the value in any TemplateVar tied to the Resource. An example would be &tvFilters=`filter2==one,filter1==bar%||filter1==foo`. <br \\/>NOTE: filtering by values uses a LIKE query and % is considered a wildcard. <br \\/>ANOTHER NOTE: This only looks at the raw value set for specific Resource, i. e. there must be a value specifically set for the Resource and it is not evaluated.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:21:\\"tvFiltersAndDelimiter\\";a:7:{s:4:\\"name\\";s:21:\\"tvFiltersAndDelimiter\\";s:4:\\"desc\\";s:83:\\"The delimiter to use to separate logical AND expressions in tvFilters. Default is ,\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\",\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:20:\\"tvFiltersOrDelimiter\\";a:7:{s:4:\\"name\\";s:20:\\"tvFiltersOrDelimiter\\";s:4:\\"desc\\";s:83:\\"The delimiter to use to separate logical OR expressions in tvFilters. Default is ||\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:2:\\"||\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"depth\\";a:7:{s:4:\\"name\\";s:5:\\"depth\\";s:4:\\"desc\\";s:88:\\"Integer value indicating depth to search for resources from each parent. Defaults to 10.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:2:\\"10\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"parents\\";a:7:{s:4:\\"name\\";s:7:\\"parents\\";s:4:\\"desc\\";s:57:\\"Optional. Comma-delimited list of ids serving as parents.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:14:\\"includeContent\\";a:7:{s:4:\\"name\\";s:14:\\"includeContent\\";s:4:\\"desc\\";s:95:\\"Indicates if the content of each resource should be returned in the results. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"includeTVs\\";a:7:{s:4:\\"name\\";s:10:\\"includeTVs\\";s:4:\\"desc\\";s:124:\\"Indicates if TemplateVar values should be included in the properties available to each resource template. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:13:\\"includeTVList\\";a:7:{s:4:\\"name\\";s:13:\\"includeTVList\\";s:4:\\"desc\\";s:96:\\"Limits included TVs to those specified as a comma-delimited list of TV names. Defaults to empty.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"showHidden\\";a:7:{s:4:\\"name\\";s:10:\\"showHidden\\";s:4:\\"desc\\";s:85:\\"Indicates if Resources that are hidden from menus should be shown. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:15:\\"showUnpublished\\";a:7:{s:4:\\"name\\";s:15:\\"showUnpublished\\";s:4:\\"desc\\";s:79:\\"Indicates if Resources that are unpublished should be shown. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:11:\\"showDeleted\\";a:7:{s:4:\\"name\\";s:11:\\"showDeleted\\";s:4:\\"desc\\";s:75:\\"Indicates if Resources that are deleted should be shown. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:9:\\"resources\\";a:7:{s:4:\\"name\\";s:9:\\"resources\\";s:4:\\"desc\\";s:177:\\"A comma-separated list of resource IDs to exclude or include. IDs with a - in front mean to exclude. Ex: 123,-456 means to include Resource 123, but always exclude Resource 456.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"processTVs\\";a:7:{s:4:\\"name\\";s:10:\\"processTVs\\";s:4:\\"desc\\";s:117:\\"Indicates if TemplateVar values should be rendered as they would on the resource being summarized. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:13:\\"processTVList\\";a:7:{s:4:\\"name\\";s:13:\\"processTVList\\";s:4:\\"desc\\";s:166:\\"Limits processed TVs to those specified as a comma-delimited list of TV names; note only includedTVs will be available for processing if specified. Defaults to empty.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"prepareTVs\\";a:7:{s:4:\\"name\\";s:10:\\"prepareTVs\\";s:4:\\"desc\\";s:120:\\"Indicates if TemplateVar values that are not processed fully should be prepared before being returned. Defaults to true.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:1;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:13:\\"prepareTVList\\";a:7:{s:4:\\"name\\";s:13:\\"prepareTVList\\";s:4:\\"desc\\";s:164:\\"Limits prepared TVs to those specified as a comma-delimited list of TV names; note only includedTVs will be available for preparing if specified. Defaults to empty.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:8:\\"tvPrefix\\";a:7:{s:4:\\"name\\";s:8:\\"tvPrefix\\";s:4:\\"desc\\";s:55:\\"The prefix for TemplateVar properties. Defaults to: tv.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:3:\\"tv.\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:3:\\"idx\\";a:7:{s:4:\\"name\\";s:3:\\"idx\\";s:4:\\"desc\\";s:120:\\"You can define the starting idx of the resources, which is an property that is incremented as each resource is rendered.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"first\\";a:7:{s:4:\\"name\\";s:5:\\"first\\";s:4:\\"desc\\";s:81:\\"Define the idx which represents the first resource (see tplFirst). Defaults to 1.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:4:\\"last\\";a:7:{s:4:\\"name\\";s:4:\\"last\\";s:4:\\"desc\\";s:129:\\"Define the idx which represents the last resource (see tplLast). Defaults to the number of resources being summarized + first - 1\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:13:\\"toPlaceholder\\";a:7:{s:4:\\"name\\";s:13:\\"toPlaceholder\\";s:4:\\"desc\\";s:85:\\"If set, will assign the result to this placeholder instead of outputting it directly.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:22:\\"toSeparatePlaceholders\\";a:7:{s:4:\\"name\\";s:22:\\"toSeparatePlaceholders\\";s:4:\\"desc\\";s:130:\\"If set, will assign EACH result to a separate placeholder named by this param suffixed with a sequential number (starting from 0).\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"debug\\";a:7:{s:4:\\"name\\";s:5:\\"debug\\";s:4:\\"desc\\";s:68:\\"If true, will send the SQL query to the MODX log. Defaults to false.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"where\\";a:7:{s:4:\\"name\\";s:5:\\"where\\";s:4:\\"desc\\";s:193:\\"A JSON expression of criteria to build any additional where clauses from, e.g. &where=`{{\\"alias:LIKE\\":\\"foo%\\", \\"OR:alias:LIKE\\":\\"%bar\\"},{\\"OR:pagetitle:=\\":\\"foobar\\", \\"AND:description:=\\":\\"raboof\\"}}`\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:11:\\"dbCacheFlag\\";a:7:{s:4:\\"name\\";s:11:\\"dbCacheFlag\\";s:4:\\"desc\\";s:218:\\"Determines how result sets are cached if cache_db is enabled in MODX. 0|false = do not cache result set; 1 = cache result set according to cache settings, any other integer value = number of seconds to cache result set\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"context\\";a:7:{s:4:\\"name\\";s:7:\\"context\\";s:4:\\"desc\\";s:116:\\"A comma-delimited list of context keys for limiting results. Default is empty, i.e. do not limit results by context.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:12:\\"tplCondition\\";a:7:{s:4:\\"name\\";s:12:\\"tplCondition\\";s:4:\\"desc\\";s:129:\\"A condition to compare against the conditionalTpls property to map Resources to different tpls based on custom conditional logic.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:11:\\"tplOperator\\";a:7:{s:4:\\"name\\";s:11:\\"tplOperator\\";s:4:\\"desc\\";s:125:\\"An optional operator to use for the tplCondition when comparing against the conditionalTpls operands. Default is == (equals).\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:10:{i:0;a:2:{s:4:\\"text\\";s:11:\\"is equal to\\";s:5:\\"value\\";s:2:\\"==\\";}i:1;a:2:{s:4:\\"text\\";s:15:\\"is not equal to\\";s:5:\\"value\\";s:2:\\"!=\\";}i:2;a:2:{s:4:\\"text\\";s:9:\\"less than\\";s:5:\\"value\\";s:1:\\"<\\";}i:3;a:2:{s:4:\\"text\\";s:21:\\"less than or equal to\\";s:5:\\"value\\";s:2:\\"<=\\";}i:4;a:2:{s:4:\\"text\\";s:24:\\"greater than or equal to\\";s:5:\\"value\\";s:2:\\">=\\";}i:5;a:2:{s:4:\\"text\\";s:8:\\"is empty\\";s:5:\\"value\\";s:5:\\"empty\\";}i:6;a:2:{s:4:\\"text\\";s:12:\\"is not empty\\";s:5:\\"value\\";s:6:\\"!empty\\";}i:7;a:2:{s:4:\\"text\\";s:7:\\"is null\\";s:5:\\"value\\";s:4:\\"null\\";}i:8;a:2:{s:4:\\"text\\";s:11:\\"is in array\\";s:5:\\"value\\";s:7:\\"inarray\\";}i:9;a:2:{s:4:\\"text\\";s:10:\\"is between\\";s:5:\\"value\\";s:7:\\"between\\";}}s:5:\\"value\\";s:2:\\"==\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:15:\\"conditionalTpls\\";a:7:{s:4:\\"name\\";s:15:\\"conditionalTpls\\";s:4:\\"desc\\";s:121:\\"A JSON map of conditional operands and tpls to compare against the tplCondition property using the specified tplOperator.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * getResources\\n *\\n * A general purpose Resource listing and summarization snippet for MODX 2.x.\\n *\\n * @author Jason Coward\\n * @copyright Copyright 2010-2013, Jason Coward\\n *\\n * TEMPLATES\\n *\\n * tpl - Name of a chunk serving as a resource template\\n * [NOTE: if not provided, properties are dumped to output for each resource]\\n *\\n * tplOdd - (Opt) Name of a chunk serving as resource template for resources with an odd idx value\\n * (see idx property)\\n * tplFirst - (Opt) Name of a chunk serving as resource template for the first resource (see first\\n * property)\\n * tplLast - (Opt) Name of a chunk serving as resource template for the last resource (see last\\n * property)\\n * tpl_{n} - (Opt) Name of a chunk serving as resource template for the nth resource\\n *\\n * tplCondition - (Opt) Defines a field of the resource to evaluate against keys defined in the\\n * conditionalTpls property. Must be a resource field; does not work with Template Variables.\\n * conditionalTpls - (Opt) A JSON object defining a map of field values and the associated tpl to\\n * use when the field defined by tplCondition matches the value. [NOTE: tplOdd, tplFirst, tplLast,\\n * and tpl_{n} will take precedence over any defined conditionalTpls]\\n *\\n * tplWrapper - (Opt) Name of a chunk serving as a wrapper template for the output\\n * [NOTE: Does not work with toSeparatePlaceholders]\\n *\\n * SELECTION\\n *\\n * parents - Comma-delimited list of ids serving as parents\\n *\\n * context - (Opt) Comma-delimited list of context keys to limit results by; if empty, contexts for all specified\\n * parents will be used (all contexts if 0 is specified) [default=]\\n *\\n * depth - (Opt) Integer value indicating depth to search for resources from each parent [default=10]\\n *\\n * tvFilters - (Opt) Delimited-list of TemplateVar values to filter resources by. Supports two\\n * delimiters and two value search formats. The first delimiter || represents a logical OR and the\\n * primary grouping mechanism.  Within each group you can provide a comma-delimited list of values.\\n * These values can be either tied to a specific TemplateVar by name, e.g. myTV==value, or just the\\n * value, indicating you are searching for the value in any TemplateVar tied to the Resource. An\\n * example would be &tvFilters=`filter2==one,filter1==bar%||filter1==foo`\\n * [NOTE: filtering by values uses a LIKE query and % is considered a wildcard.]\\n * [NOTE: this only looks at the raw value set for specific Resource, i. e. there must be a value\\n * specifically set for the Resource and it is not evaluated.]\\n *\\n * tvFiltersAndDelimiter - (Opt) Custom delimiter for logical AND, default \',\', in case you want to\\n * match a literal comma in the tvFilters. E.g. &tvFiltersAndDelimiter=`&&`\\n * &tvFilters=`filter1==foo,bar&&filter2==baz` [default=,]\\n *\\n * tvFiltersOrDelimiter - (Opt) Custom delimiter for logical OR, default \'||\', in case you want to\\n * match a literal \'||\' in the tvFilters. E.g. &tvFiltersOrDelimiter=`|OR|`\\n * &tvFilters=`filter1==foo||bar|OR|filter2==baz` [default=||]\\n *\\n * where - (Opt) A JSON expression of criteria to build any additional where clauses from. An example would be\\n * &where=`{{\\"alias:LIKE\\":\\"foo%\\", \\"OR:alias:LIKE\\":\\"%bar\\"},{\\"OR:pagetitle:=\\":\\"foobar\\", \\"AND:description:=\\":\\"raboof\\"}}`\\n *\\n * sortby - (Opt) Field to sort by or a JSON array, e.g. {\\"publishedon\\":\\"ASC\\",\\"createdon\\":\\"DESC\\"} [default=publishedon]\\n * sortbyTV - (opt) A Template Variable name to sort by (if supplied, this precedes the sortby value) [default=]\\n * sortbyTVType - (Opt) A data type to CAST a TV Value to in order to sort on it properly [default=string]\\n * sortbyAlias - (Opt) Query alias for sortby field [default=]\\n * sortbyEscaped - (Opt) Escapes the field name(s) specified in sortby [default=0]\\n * sortdir - (Opt) Order which to sort by [default=DESC]\\n * sortdirTV - (Opt) Order which to sort by a TV [default=DESC]\\n * limit - (Opt) Limits the number of resources returned [default=5]\\n * offset - (Opt) An offset of resources returned by the criteria to skip [default=0]\\n * dbCacheFlag - (Opt) Controls caching of db queries; 0|false = do not cache result set; 1 = cache result set\\n * according to cache settings, any other integer value = number of seconds to cache result set [default=0]\\n *\\n * OPTIONS\\n *\\n * includeContent - (Opt) Indicates if the content of each resource should be returned in the\\n * results [default=0]\\n * includeTVs - (Opt) Indicates if TemplateVar values should be included in the properties available\\n * to each resource template [default=0]\\n * includeTVList - (Opt) Limits the TemplateVars that are included if includeTVs is true to those specified\\n * by name in a comma-delimited list [default=]\\n * prepareTVs - (Opt) Prepares media-source dependent TemplateVar values [default=1]\\n * prepareTVList - (Opt) Limits the TVs that are prepared to those specified by name in a comma-delimited\\n * list [default=]\\n * processTVs - (Opt) Indicates if TemplateVar values should be rendered as they would on the\\n * resource being summarized [default=0]\\n * processTVList - (opt) Limits the TemplateVars that are processed if included to those specified\\n * by name in a comma-delimited list [default=]\\n * tvPrefix - (Opt) The prefix for TemplateVar properties [default=tv.]\\n * idx - (Opt) You can define the starting idx of the resources, which is an property that is\\n * incremented as each resource is rendered [default=1]\\n * first - (Opt) Define the idx which represents the first resource (see tplFirst) [default=1]\\n * last - (Opt) Define the idx which represents the last resource (see tplLast) [default=# of\\n * resources being summarized + first - 1]\\n * outputSeparator - (Opt) An optional string to separate each tpl instance [default=\\"\\\\n\\"]\\n * wrapIfEmpty - (Opt) Indicates if the tplWrapper should be applied if the output is empty [default=0]\\n *\\n *\\/\\n$output = array();\\n$outputSeparator = isset($outputSeparator) ? $outputSeparator : \\"\\\\n\\";\\n\\n\\/* set default properties *\\/\\n$tpl = !empty($tpl) ? $tpl : \'\';\\n$includeContent = !empty($includeContent) ? true : false;\\n$includeTVs = !empty($includeTVs) ? true : false;\\n$includeTVList = !empty($includeTVList) ? explode(\',\', $includeTVList) : array();\\n$processTVs = !empty($processTVs) ? true : false;\\n$processTVList = !empty($processTVList) ? explode(\',\', $processTVList) : array();\\n$prepareTVs = !empty($prepareTVs) ? true : false;\\n$prepareTVList = !empty($prepareTVList) ? explode(\',\', $prepareTVList) : array();\\n$tvPrefix = isset($tvPrefix) ? $tvPrefix : \'tv.\';\\n$parents = (!empty($parents) || $parents === \'0\') ? explode(\',\', $parents) : array($modx->resource->get(\'id\'));\\narray_walk($parents, \'trim\');\\n$parents = array_unique($parents);\\n$depth = isset($depth) ? (integer) $depth : 10;\\n\\n$tvFiltersOrDelimiter = isset($tvFiltersOrDelimiter) ? $tvFiltersOrDelimiter : \'||\';\\n$tvFiltersAndDelimiter = isset($tvFiltersAndDelimiter) ? $tvFiltersAndDelimiter : \',\';\\n$tvFilters = !empty($tvFilters) ? explode($tvFiltersOrDelimiter, $tvFilters) : array();\\n\\n$where = !empty($where) ? $modx->fromJSON($where) : array();\\n$showUnpublished = !empty($showUnpublished) ? true : false;\\n$showDeleted = !empty($showDeleted) ? true : false;\\n\\n$sortby = isset($sortby) ? $sortby : \'publishedon\';\\n$sortbyTV = isset($sortbyTV) ? $sortbyTV : \'\';\\n$sortbyAlias = isset($sortbyAlias) ? $sortbyAlias : \'modResource\';\\n$sortbyEscaped = !empty($sortbyEscaped) ? true : false;\\n$sortdir = isset($sortdir) ? $sortdir : \'DESC\';\\n$sortdirTV = isset($sortdirTV) ? $sortdirTV : \'DESC\';\\n$limit = isset($limit) ? (integer) $limit : 5;\\n$offset = isset($offset) ? (integer) $offset : 0;\\n$totalVar = !empty($totalVar) ? $totalVar : \'total\';\\n\\n$dbCacheFlag = !isset($dbCacheFlag) ? false : $dbCacheFlag;\\nif (is_string($dbCacheFlag) || is_numeric($dbCacheFlag)) {\\n    if ($dbCacheFlag == \'0\') {\\n        $dbCacheFlag = false;\\n    } elseif ($dbCacheFlag == \'1\') {\\n        $dbCacheFlag = true;\\n    } else {\\n        $dbCacheFlag = (integer) $dbCacheFlag;\\n    }\\n}\\n\\n\\/* multiple context support *\\/\\n$contextArray = array();\\n$contextSpecified = false;\\nif (!empty($context)) {\\n    $contextArray = explode(\',\',$context);\\n    array_walk($contextArray, \'trim\');\\n    $contexts = array();\\n    foreach ($contextArray as $ctx) {\\n        $contexts[] = $modx->quote($ctx);\\n    }\\n    $context = implode(\',\',$contexts);\\n    $contextSpecified = true;\\n    unset($contexts,$ctx);\\n} else {\\n    $context = $modx->quote($modx->context->get(\'key\'));\\n}\\n\\n$pcMap = array();\\n$pcQuery = $modx->newQuery(\'modResource\', array(\'id:IN\' => $parents), $dbCacheFlag);\\n$pcQuery->select(array(\'id\', \'context_key\'));\\nif ($pcQuery->prepare() && $pcQuery->stmt->execute()) {\\n    foreach ($pcQuery->stmt->fetchAll(PDO::FETCH_ASSOC) as $pcRow) {\\n        $pcMap[(integer) $pcRow[\'id\']] = $pcRow[\'context_key\'];\\n    }\\n}\\n\\n$children = array();\\n$parentArray = array();\\nforeach ($parents as $parent) {\\n    $parent = (integer) $parent;\\n    if ($parent === 0) {\\n        $pchildren = array();\\n        if ($contextSpecified) {\\n            foreach ($contextArray as $pCtx) {\\n                if (!in_array($pCtx, $contextArray)) {\\n                    continue;\\n                }\\n                $options = $pCtx !== $modx->context->get(\'key\') ? array(\'context\' => $pCtx) : array();\\n                $pcchildren = $modx->getChildIds($parent, $depth, $options);\\n                if (!empty($pcchildren)) $pchildren = array_merge($pchildren, $pcchildren);\\n            }\\n        } else {\\n            $cQuery = $modx->newQuery(\'modContext\', array(\'key:!=\' => \'mgr\'));\\n            $cQuery->select(array(\'key\'));\\n            if ($cQuery->prepare() && $cQuery->stmt->execute()) {\\n                foreach ($cQuery->stmt->fetchAll(PDO::FETCH_COLUMN) as $pCtx) {\\n                    $options = $pCtx !== $modx->context->get(\'key\') ? array(\'context\' => $pCtx) : array();\\n                    $pcchildren = $modx->getChildIds($parent, $depth, $options);\\n                    if (!empty($pcchildren)) $pchildren = array_merge($pchildren, $pcchildren);\\n                }\\n            }\\n        }\\n        $parentArray[] = $parent;\\n    } else {\\n        $pContext = array_key_exists($parent, $pcMap) ? $pcMap[$parent] : false;\\n        if ($debug) $modx->log(modX::LOG_LEVEL_ERROR, \\"context for {$parent} is {$pContext}\\");\\n        if ($pContext && $contextSpecified && !in_array($pContext, $contextArray, true)) {\\n            $parent = next($parents);\\n            continue;\\n        }\\n        $parentArray[] = $parent;\\n        $options = !empty($pContext) && $pContext !== $modx->context->get(\'key\') ? array(\'context\' => $pContext) : array();\\n        $pchildren = $modx->getChildIds($parent, $depth, $options);\\n    }\\n    if (!empty($pchildren)) $children = array_merge($children, $pchildren);\\n    $parent = next($parents);\\n}\\n$parents = array_merge($parentArray, $children);\\n\\n\\/* build query *\\/\\n$criteria = array(\\"modResource.parent IN (\\" . implode(\',\', $parents) . \\")\\");\\nif ($contextSpecified) {\\n    $contextResourceTbl = $modx->getTableName(\'modContextResource\');\\n    $criteria[] = \\"(modResource.context_key IN ({$context}) OR EXISTS(SELECT 1 FROM {$contextResourceTbl} ctx WHERE ctx.resource = modResource.id AND ctx.context_key IN ({$context})))\\";\\n}\\nif (empty($showDeleted)) {\\n    $criteria[\'deleted\'] = \'0\';\\n}\\nif (empty($showUnpublished)) {\\n    $criteria[\'published\'] = \'1\';\\n}\\nif (empty($showHidden)) {\\n    $criteria[\'hidemenu\'] = \'0\';\\n}\\nif (!empty($hideContainers)) {\\n    $criteria[\'isfolder\'] = \'0\';\\n}\\n$criteria = $modx->newQuery(\'modResource\', $criteria);\\nif (!empty($tvFilters)) {\\n    $tmplVarTbl = $modx->getTableName(\'modTemplateVar\');\\n    $tmplVarResourceTbl = $modx->getTableName(\'modTemplateVarResource\');\\n    $conditions = array();\\n    $operators = array(\\n        \'<=>\' => \'<=>\',\\n        \'===\' => \'=\',\\n        \'!==\' => \'!=\',\\n        \'<>\' => \'<>\',\\n        \'==\' => \'LIKE\',\\n        \'!=\' => \'NOT LIKE\',\\n        \'<<\' => \'<\',\\n        \'<=\' => \'<=\',\\n        \'=<\' => \'=<\',\\n        \'>>\' => \'>\',\\n        \'>=\' => \'>=\',\\n        \'=>\' => \'=>\'\\n    );\\n    foreach ($tvFilters as $fGroup => $tvFilter) {\\n        $filterGroup = array();\\n        $filters = explode($tvFiltersAndDelimiter, $tvFilter);\\n        $multiple = count($filters) > 0;\\n        foreach ($filters as $filter) {\\n            $operator = \'==\';\\n            $sqlOperator = \'LIKE\';\\n            foreach ($operators as $op => $opSymbol) {\\n                if (strpos($filter, $op, 1) !== false) {\\n                    $operator = $op;\\n                    $sqlOperator = $opSymbol;\\n                    break;\\n                }\\n            }\\n            $tvValueField = \'tvr.value\';\\n            $tvDefaultField = \'tv.default_text\';\\n            $f = explode($operator, $filter);\\n            if (count($f) >= 2) {\\n                if (count($f) > 2) {\\n                    $k = array_shift($f);\\n                    $b = join($operator, $f);\\n                    $f = array($k, $b);\\n                }\\n                $tvName = $modx->quote($f[0]);\\n                if (is_numeric($f[1]) && !in_array($sqlOperator, array(\'LIKE\', \'NOT LIKE\'))) {\\n                    $tvValue = $f[1];\\n                    if ($f[1] == (integer)$f[1]) {\\n                        $tvValueField = \\"CAST({$tvValueField} AS SIGNED INTEGER)\\";\\n                        $tvDefaultField = \\"CAST({$tvDefaultField} AS SIGNED INTEGER)\\";\\n                    } else {\\n                        $tvValueField = \\"CAST({$tvValueField} AS DECIMAL)\\";\\n                        $tvDefaultField = \\"CAST({$tvDefaultField} AS DECIMAL)\\";\\n                    }\\n                } else {\\n                    $tvValue = $modx->quote($f[1]);\\n                }\\n                if ($multiple) {\\n                    $filterGroup[] =\\n                        \\"(EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.name = {$tvName} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id) \\" .\\n                        \\"OR EXISTS (SELECT 1 FROM {$tmplVarTbl} tv WHERE tv.name = {$tvName} AND {$tvDefaultField} {$sqlOperator} {$tvValue} AND tv.id NOT IN (SELECT tmplvarid FROM {$tmplVarResourceTbl} WHERE contentid = modResource.id)) \\" .\\n                        \\")\\";\\n                } else {\\n                    $filterGroup =\\n                        \\"(EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.name = {$tvName} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id) \\" .\\n                        \\"OR EXISTS (SELECT 1 FROM {$tmplVarTbl} tv WHERE tv.name = {$tvName} AND {$tvDefaultField} {$sqlOperator} {$tvValue} AND tv.id NOT IN (SELECT tmplvarid FROM {$tmplVarResourceTbl} WHERE contentid = modResource.id)) \\" .\\n                        \\")\\";\\n                }\\n            } elseif (count($f) == 1) {\\n                $tvValue = $modx->quote($f[0]);\\n                if ($multiple) {\\n                    $filterGroup[] = \\"EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id)\\";\\n                } else {\\n                    $filterGroup = \\"EXISTS (SELECT 1 FROM {$tmplVarResourceTbl} tvr JOIN {$tmplVarTbl} tv ON {$tvValueField} {$sqlOperator} {$tvValue} AND tv.id = tvr.tmplvarid WHERE tvr.contentid = modResource.id)\\";\\n                }\\n            }\\n        }\\n        $conditions[] = $filterGroup;\\n    }\\n    if (!empty($conditions)) {\\n        $firstGroup = true;\\n        foreach ($conditions as $cGroup => $c) {\\n            if (is_array($c)) {\\n                $first = true;\\n                foreach ($c as $cond) {\\n                    if ($first && !$firstGroup) {\\n                        $criteria->condition($criteria->query[\'where\'][0][1], $cond, xPDOQuery::SQL_OR, null, $cGroup);\\n                    } else {\\n                        $criteria->condition($criteria->query[\'where\'][0][1], $cond, xPDOQuery::SQL_AND, null, $cGroup);\\n                    }\\n                    $first = false;\\n                }\\n            } else {\\n                $criteria->condition($criteria->query[\'where\'][0][1], $c, $firstGroup ? xPDOQuery::SQL_AND : xPDOQuery::SQL_OR, null, $cGroup);\\n            }\\n            $firstGroup = false;\\n        }\\n    }\\n}\\n\\/* include\\/exclude resources, via &resources=`123,-456` prop *\\/\\nif (!empty($resources)) {\\n    $resourceConditions = array();\\n    $resources = explode(\',\',$resources);\\n    $include = array();\\n    $exclude = array();\\n    foreach ($resources as $resource) {\\n        $resource = (int)$resource;\\n        if ($resource == 0) continue;\\n        if ($resource < 0) {\\n            $exclude[] = abs($resource);\\n        } else {\\n            $include[] = $resource;\\n        }\\n    }\\n    if (!empty($include)) {\\n        $criteria->where(array(\'OR:modResource.id:IN\' => $include), xPDOQuery::SQL_OR);\\n    }\\n    if (!empty($exclude)) {\\n        $criteria->where(array(\'modResource.id:NOT IN\' => $exclude), xPDOQuery::SQL_AND, null, 1);\\n    }\\n}\\nif (!empty($where)) {\\n    $criteria->where($where);\\n}\\n\\n$total = $modx->getCount(\'modResource\', $criteria);\\n$modx->setPlaceholder($totalVar, $total);\\n\\n$fields = array_keys($modx->getFields(\'modResource\'));\\nif (empty($includeContent)) {\\n    $fields = array_diff($fields, array(\'content\'));\\n}\\n$columns = $includeContent ? $modx->getSelectColumns(\'modResource\', \'modResource\') : $modx->getSelectColumns(\'modResource\', \'modResource\', \'\', array(\'content\'), true);\\n$criteria->select($columns);\\nif (!empty($sortbyTV)) {\\n    $criteria->leftJoin(\'modTemplateVar\', \'tvDefault\', array(\\n        \\"tvDefault.name\\" => $sortbyTV\\n    ));\\n    $criteria->leftJoin(\'modTemplateVarResource\', \'tvSort\', array(\\n        \\"tvSort.contentid = modResource.id\\",\\n        \\"tvSort.tmplvarid = tvDefault.id\\"\\n    ));\\n    if (empty($sortbyTVType)) $sortbyTVType = \'string\';\\n    if ($modx->getOption(\'dbtype\') === \'mysql\') {\\n        switch ($sortbyTVType) {\\n            case \'integer\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS SIGNED INTEGER) AS sortTV\\");\\n                break;\\n            case \'decimal\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS DECIMAL) AS sortTV\\");\\n                break;\\n            case \'datetime\':\\n                $criteria->select(\\"CAST(IFNULL(tvSort.value, tvDefault.default_text) AS DATETIME) AS sortTV\\");\\n                break;\\n            case \'string\':\\n            default:\\n                $criteria->select(\\"IFNULL(tvSort.value, tvDefault.default_text) AS sortTV\\");\\n                break;\\n        }\\n    } elseif ($modx->getOption(\'dbtype\') === \'sqlsrv\') {\\n        switch ($sortbyTVType) {\\n            case \'integer\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS BIGINT) AS sortTV\\");\\n                break;\\n            case \'decimal\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS DECIMAL) AS sortTV\\");\\n                break;\\n            case \'datetime\':\\n                $criteria->select(\\"CAST(ISNULL(tvSort.value, tvDefault.default_text) AS DATETIME) AS sortTV\\");\\n                break;\\n            case \'string\':\\n            default:\\n                $criteria->select(\\"ISNULL(tvSort.value, tvDefault.default_text) AS sortTV\\");\\n                break;\\n        }\\n    }\\n    $criteria->sortby(\\"sortTV\\", $sortdirTV);\\n}\\nif (!empty($sortby)) {\\n    if (strpos($sortby, \'{\') === 0) {\\n        $sorts = $modx->fromJSON($sortby);\\n    } else {\\n        $sorts = array($sortby => $sortdir);\\n    }\\n    if (is_array($sorts)) {\\n        while (list($sort, $dir) = each($sorts)) {\\n            if ($sortbyEscaped) $sort = $modx->escape($sort);\\n            if (!empty($sortbyAlias)) $sort = $modx->escape($sortbyAlias) . \\".{$sort}\\";\\n            $criteria->sortby($sort, $dir);\\n        }\\n    }\\n}\\nif (!empty($limit)) $criteria->limit($limit, $offset);\\n\\nif (!empty($debug)) {\\n    $criteria->prepare();\\n    $modx->log(modX::LOG_LEVEL_ERROR, $criteria->toSQL());\\n}\\n$collection = $modx->getCollection(\'modResource\', $criteria, $dbCacheFlag);\\n\\n$idx = !empty($idx) || $idx === \'0\' ? (integer) $idx : 1;\\n$first = empty($first) && $first !== \'0\' ? 1 : (integer) $first;\\n$last = empty($last) ? (count($collection) + $idx - 1) : (integer) $last;\\n\\n\\/* include parseTpl *\\/\\ninclude_once $modx->getOption(\'getresources.core_path\',null,$modx->getOption(\'core_path\').\'components\\/getresources\\/\').\'include.parsetpl.php\';\\n\\n$templateVars = array();\\nif (!empty($includeTVs) && !empty($includeTVList)) {\\n    $templateVars = $modx->getCollection(\'modTemplateVar\', array(\'name:IN\' => $includeTVList));\\n}\\n\\/** @var modResource $resource *\\/\\nforeach ($collection as $resourceId => $resource) {\\n    $tvs = array();\\n    if (!empty($includeTVs)) {\\n        if (empty($includeTVList)) {\\n            $templateVars = $resource->getMany(\'TemplateVars\');\\n        }\\n        \\/** @var modTemplateVar $templateVar *\\/\\n        foreach ($templateVars as $tvId => $templateVar) {\\n            if (!empty($includeTVList) && !in_array($templateVar->get(\'name\'), $includeTVList)) continue;\\n            if ($processTVs && (empty($processTVList) || in_array($templateVar->get(\'name\'), $processTVList))) {\\n                $tvs[$tvPrefix . $templateVar->get(\'name\')] = $templateVar->renderOutput($resource->get(\'id\'));\\n            } else {\\n                $value = $templateVar->getValue($resource->get(\'id\'));\\n                if ($prepareTVs && method_exists($templateVar, \'prepareOutput\') && (empty($prepareTVList) || in_array($templateVar->get(\'name\'), $prepareTVList))) {\\n                    $value = $templateVar->prepareOutput($value);\\n                }\\n                $tvs[$tvPrefix . $templateVar->get(\'name\')] = $value;\\n            }\\n        }\\n    }\\n    $odd = ($idx & 1);\\n    $properties = array_merge(\\n        $scriptProperties\\n        ,array(\\n            \'idx\' => $idx\\n            ,\'first\' => $first\\n            ,\'last\' => $last\\n            ,\'odd\' => $odd\\n        )\\n        ,$includeContent ? $resource->toArray() : $resource->get($fields)\\n        ,$tvs\\n    );\\n    $resourceTpl = false;\\n    if ($idx == $first && !empty($tplFirst)) {\\n        $resourceTpl = parseTpl($tplFirst, $properties);\\n    }\\n    if ($idx == $last && empty($resourceTpl) && !empty($tplLast)) {\\n        $resourceTpl = parseTpl($tplLast, $properties);\\n    }\\n    $tplidx = \'tpl_\' . $idx;\\n    if (empty($resourceTpl) && !empty($$tplidx)) {\\n        $resourceTpl = parseTpl($$tplidx, $properties);\\n    }\\n    if ($idx > 1 && empty($resourceTpl)) {\\n        $divisors = getDivisors($idx);\\n        if (!empty($divisors)) {\\n            foreach ($divisors as $divisor) {\\n                $tplnth = \'tpl_n\' . $divisor;\\n                if (!empty($$tplnth)) {\\n                    $resourceTpl = parseTpl($$tplnth, $properties);\\n                    if (!empty($resourceTpl)) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    if ($odd && empty($resourceTpl) && !empty($tplOdd)) {\\n        $resourceTpl = parseTpl($tplOdd, $properties);\\n    }\\n    if (!empty($tplCondition) && !empty($conditionalTpls) && empty($resourceTpl)) {\\n        $conTpls = $modx->fromJSON($conditionalTpls);\\n        $subject = $properties[$tplCondition];\\n        $tplOperator = !empty($tplOperator) ? $tplOperator : \'=\';\\n        $tplOperator = strtolower($tplOperator);\\n        $tplCon = \'\';\\n        foreach ($conTpls as $operand => $conditionalTpl) {\\n            switch ($tplOperator) {\\n                case \'!=\':\\n                case \'neq\':\\n                case \'not\':\\n                case \'isnot\':\\n                case \'isnt\':\\n                case \'unequal\':\\n                case \'notequal\':\\n                    $tplCon = (($subject != $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'<\':\\n                case \'lt\':\\n                case \'less\':\\n                case \'lessthan\':\\n                    $tplCon = (($subject < $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'>\':\\n                case \'gt\':\\n                case \'greater\':\\n                case \'greaterthan\':\\n                    $tplCon = (($subject > $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'<=\':\\n                case \'lte\':\\n                case \'lessthanequals\':\\n                case \'lessthanorequalto\':\\n                    $tplCon = (($subject <= $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'>=\':\\n                case \'gte\':\\n                case \'greaterthanequals\':\\n                case \'greaterthanequalto\':\\n                    $tplCon = (($subject >= $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n                case \'isempty\':\\n                case \'empty\':\\n                    $tplCon = empty($subject) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'!empty\':\\n                case \'notempty\':\\n                case \'isnotempty\':\\n                    $tplCon = !empty($subject) && $subject != \'\' ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'isnull\':\\n                case \'null\':\\n                    $tplCon = $subject == null || strtolower($subject) == \'null\' ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'inarray\':\\n                case \'in_array\':\\n                case \'ia\':\\n                    $operand = explode(\',\', $operand);\\n                    $tplCon = in_array($subject, $operand) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'between\':\\n                case \'range\':\\n                case \'>=<\':\\n                case \'><\':\\n                    $operand = explode(\',\', $operand);\\n                    $tplCon = ($subject >= min($operand) && $subject <= max($operand)) ? $conditionalTpl : $tplCon;\\n                    break;\\n                case \'==\':\\n                case \'=\':\\n                case \'eq\':\\n                case \'is\':\\n                case \'equal\':\\n                case \'equals\':\\n                case \'equalto\':\\n                default:\\n                    $tplCon = (($subject == $operand) ? $conditionalTpl : $tplCon);\\n                    break;\\n            }\\n        }\\n        if (!empty($tplCon)) {\\n            $resourceTpl = parseTpl($tplCon, $properties);\\n        }\\n    }\\n    if (!empty($tpl) && empty($resourceTpl)) {\\n        $resourceTpl = parseTpl($tpl, $properties);\\n    }\\n    if ($resourceTpl === false && !empty($debug)) {\\n        $chunk = $modx->newObject(\'modChunk\');\\n        $chunk->setCacheable(false);\\n        $output[]= $chunk->process(array(), \'<pre>\' . print_r($properties, true) .\'<\\/pre>\');\\n    } else {\\n        $output[]= $resourceTpl;\\n    }\\n    $idx++;\\n}\\n\\n\\/* output *\\/\\n$toSeparatePlaceholders = $modx->getOption(\'toSeparatePlaceholders\', $scriptProperties, false);\\nif (!empty($toSeparatePlaceholders)) {\\n    $modx->setPlaceholders($output, $toSeparatePlaceholders);\\n    return \'\';\\n}\\n\\n$output = implode($outputSeparator, $output);\\n\\n$tplWrapper = $modx->getOption(\'tplWrapper\', $scriptProperties, false);\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, false);\\nif (!empty($tplWrapper) && ($wrapIfEmpty || !empty($output))) {\\n    $output = parseTpl($tplWrapper, array_merge($scriptProperties, array(\'output\' => $output)));\\n}\\n\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, false);\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $output);\\n    return \'\';\\n}\\nreturn $output;"}',
);